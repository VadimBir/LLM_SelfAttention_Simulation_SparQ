#include "cache.h"
#include <iostream>
#include <fstream>
#include <iomanip>

// MARKOVE PREFETCHER LIBS
#include <map>
#include <vector>
#include <utility>
#include <algorithm>

std::ofstream addressFile;

//std::string addressFilePath = "/home/ubuntu/Directory/SparQ/002-addressesHistory/addresses-CHANGENAME.txt"; // addresses-<TRACE_NAME>.txt
void CACHE::l2c_prefetcher_initialize()
{
    cout << "CPU " << cpu << " L2C next line prefetcher initialized" << endl;
//    addressFile.open(addressFilePath, std::ios::app);
//    if (!addressFile.is_open()) {
//        cout << "Failed to open file for writing addresses." << endl;
//    }
}

//uint32_t CACHE::get_l2_cache_occupancy() const {
//    uint32_t count = 0;
//    for (const auto& line : sets) {  // Assuming `sets` is the data structure holding cache lines
//        for (const auto& entry : line) {
//            if (entry.valid) {  // Assuming `valid` is a member indicating if the cache line is valid
//                count++;
//            }
//        }
//    }
//    return count;
//}

int ADDR_TO_SKIP = 1;
int BULK_FETCH_ADDR = 4;
uint64_t cnt = 0;


int popular_prefetch_offset_P1[] = {1, 2};
int popular_prefetch_offset_P2[] = {1, 2, 16};

int lim_part1 = 3000000;
int switchInt = 0;

// Markov Table
std::map<uint64_t, std::map<uint64_t, int>> markov_table;
const int MARKOV_TABLE_SIZE = 65536;
const int MAX_PREDICTIONS = 2;

//void print_markov_table() {
//    std::cout << "Markov Table Contents:\n";
//    for (const auto& entry : markov_table) {
//        uint64_t previous_addr = entry.first;
//        const auto& next_blocks = entry.second;
//        //std::cout << "Previous Addr: " << previous_addr << "\n";
//        for (const auto& prediction : next_blocks) {
//            uint64_t next_addr = prediction.first;
//            int hits = prediction.second;
//            std::cout << "  Next Addr: " << next_addr << " - Hits: " << hits << "\n";
//        }
//    }
//    std::cout << "End of Markov Table\n";
//}

// CREATE A MARKOVE THAT PREDICTS A FUTURE DELTA BASED ON PAST DELTA
std::vector<uint64_t> markov_prefetcher(uint64_t addr, uint64_t ip) {
    std::vector<uint64_t> top_predictions;
    //uint64_t best_prediction = -1; // Default to -1, indicating no prediction found
    auto it = markov_table.find(addr);

    //print_markov_table();
    //cout << "Bool: " << (it != markov_table.end()) << endl;
    if (it != markov_table.end()) {
        // Get the map of next likely blocks
        auto& next_blocks = it->second;

        //cout << "Next Blocks: " << next_blocks.size() << endl;
        // Create a vector and sort the predictions based on their hit counts
        std::vector<std::pair<uint64_t, int>> predictions(next_blocks.begin(), next_blocks.end());
        // vector
//        for (auto& prediction : predictions) {
//            cout << "Prediction: " << prediction.first << " - " << prediction.second << std::endl;
//        }
        std::sort(predictions.begin(), predictions.end(),
                  [](const std::pair<uint64_t, int>& a, const std::pair<uint64_t, int>& b) {
                      return a.second > b.second;  // Sort by descending hit count
                  });


        // Prefetch the top predictions
        for (auto& prediction : predictions) {
            if (top_predictions.size() >= MAX_PREDICTIONS) break; // Stop if we have enough predictions
            uint64_t pf_addr = prediction.first << LOG2_BLOCK_SIZE;
            top_predictions.push_back(pf_addr); // Store the prediction in the vector
        }
    }


    return top_predictions;
}

//uint64_t pf_addr = ((addr >> LOG2_BLOCK_SIZE) + 1) << LOG2_BLOCK_SIZE;
uint64_t previous_addr = 0;
uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{
    uint64_t pf_addr = 0;
//    addressFile.open(addressFilePath, std::ios::app);
//    if (addressFile.is_open()) {
//        addressFile << std::hex << std::setw(12) << std::setfill('0') << (addr >> LOG2_BLOCK_SIZE) << std::dec << std::endl;
//    }

//    if (cnt % ADDR_TO_SKIP == 0) {
//        for (int i = 0; i < BULK_FETCH_ADDR; i++) {
//            uint64_t pf_addr = ((addr >> LOG2_BLOCK_SIZE) + i) << LOG2_BLOCK_SIZE;
//            prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//        }
//    }
//    if (cnt%lim_part1 > 0 && cnt!=0) {
//        switch(switchInt-1) {
//            case 0:
    for (int offset : popular_prefetch_offset_P1) {
        pf_addr = ((addr >> LOG2_BLOCK_SIZE) + offset) << LOG2_BLOCK_SIZE;
        prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
    }
// USING MARKOV PREFETCHER ---------------------------------------------------------------------------------------------- MARKOV
    if (previous_addr != 0) {
        // Update the markov table
        //cout << "Previous: " << (previous_addr >> LOG2_BLOCK_SIZE)  << " Current: " << (addr >> LOG2_BLOCK_SIZE) << endl;
        markov_table[previous_addr>> LOG2_BLOCK_SIZE][addr>> LOG2_BLOCK_SIZE]++;
        //cout << "Table: " << markov_table[previous_addr][addr] << endl;
    }
    std::vector<uint64_t> pf_topP = markov_prefetcher(addr >> LOG2_BLOCK_SIZE, ip);
    for (uint64_t pf_addr : pf_topP) {
        prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
    }

// USING MARKOV PREFETCHER ---------------------------------------------------------------------------------------------- MARKOV



//                break;
//            case 1:
//                for (int offset : popular_prefetch_offset_P2) {
//                    uint64_t pf_addr = ((addr >> LOG2_BLOCK_SIZE) + offset) << LOG2_BLOCK_SIZE;
//                    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//                }
//                break;
//        }
//    } else {
//        switchInt = 1;
//        cout << "Switching to " << switchInt << endl;
//    }


// +1 +2 only 1KK 0.99992
//    uint64_t pf_addr = ((addr>>LOG2_BLOCK_SIZE)+1) << LOG2_BLOCK_SIZE;
//    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//
//    pf_addr = ((addr>>LOG2_BLOCK_SIZE)+2) << LOG2_BLOCK_SIZE;
//    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//

//    pf_addr = ((addr>>LOG2_BLOCK_SIZE)+3) << LOG2_BLOCK_SIZE;
//    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//
//    pf_addr = ((addr>>LOG2_BLOCK_SIZE)+4) << LOG2_BLOCK_SIZE;
//    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//
//
//    pf_addr = ((addr>>LOG2_BLOCK_SIZE)+8) << LOG2_BLOCK_SIZE;
//    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//
//
//    pf_addr = ((addr>>LOG2_BLOCK_SIZE)+16) << LOG2_BLOCK_SIZE;
//    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
//
//
//    pf_addr = ((addr>>LOG2_BLOCK_SIZE)+32) << LOG2_BLOCK_SIZE;
//    prefetch_line(ip, addr, pf_addr, FILL_L2, 0);

//    addressFile.close();
    // Always printing out access details
    //cout << "[" << NAME << "] " << __func__ << " base_cl: " << hex << (addr>>LOG2_BLOCK_SIZE);
    //cout << " pf_cl: " << (pf_addr>>LOG2_BLOCK_SIZE) << " ip: " << ip << " cache_hit: " << dec << +cache_hit << " type: " << +type << endl;

    //uint32_t l2_cache_occupancy = get_l2_cache_occupancy();
    //std::cout << "L2 Cache Occupancy: " << l2_cache_occupancy << std::endl;

        previous_addr = addr;
        cnt++;
        return metadata_in;
}



uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    // Outputting detailed fill information
    //cout << "[" << NAME << "] " << __func__ << " addr: " << hex << addr << " set: " << dec << set;
    //cout << " way: " << way << " prefetch: " << +prefetch << " evicted_addr: " << hex << evicted_addr << dec <<endl;


//    if (addressFile.is_open()) {
//        addressFile << std::hex << addr << std::dec << std::endl;
//    }

    return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L2C next line prefetcher final stats" << endl;
//    if (addressFile.is_open()) {
//        addressFile.close();
//    } else {
//        cout << "File was never opened for writing." << endl;
//    }
}